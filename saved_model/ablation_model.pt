import os
import cv2
import torch
import lpips
import numpy as np
import pandas as pd
from tqdm import tqdm
from skimage.metrics import structural_similarity as compare_ssim
import math

# === Import your model variants ===
from models.unet import unet
from models.denseunet import denseunet
from models.cbam_unet import cbam_unet
from models.cbam_denseunet import cbam_denseunet
from models.cbam_denseunet_retinex import cbam_denseunet_retinex  # Custom with Retinex

# === Device ===
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# === LPIPS ===
lpips_fn = lpips.LPIPS(net='vgg').to(device)

# === Metric Functions ===
def calculate_psnr(img1, img2):
    mse = np.mean((img1 - img2) ** 2)
    if mse == 0:
        return 100
    return 10 * math.log10(1.0 / mse)

def calculate_ssim(img1, img2):
    return np.mean([compare_ssim(img1[..., i], img2[..., i], data_range=1.0) for i in range(3)])

# === Retinex Decomposition (Simplified MSR) ===
def retinex_decomposition(img, sigma_list=[15, 80, 250]):
    img = img.astype(np.float32) + 1.0
    log_img = np.log(img)
    retinex = np.zeros_like(log_img)
    for sigma in sigma_list:
        blur = cv2.GaussianBlur(img, (0, 0), sigma)
        retinex += log_img - np.log(blur + 1.0)
    retinex = retinex / len(sigma_list)
    return cv2.normalize(retinex, None, 0, 1, cv2.NORM_MINMAX)

# === Evaluation ===
def evaluate_model(model, high_dir, low_dir, use_retinex=False):
    model.eval()
    psnr_list, ssim_list, lpips_list = [], [], []
    
    with torch.no_grad():
        for fname in tqdm(sorted(os.listdir(high_dir)), desc=f"Evaluating {model.__class__.__name__}"):
            high_path = os.path.join(high_dir, fname)
            low_path = os.path.join(low_dir, fname)

            high_img = cv2.cvtColor(cv2.imread(high_path), cv2.COLOR_BGR2RGB) / 255.0
            low_img = cv2.cvtColor(cv2.imread(low_path), cv2.COLOR_BGR2RGB) / 255.0

            if use_retinex:
                low_img = retinex_decomposition((low_img * 255).astype(np.uint8))

            inp_tensor = torch.tensor(low_img).permute(2, 0, 1).unsqueeze(0).float().to(device)
            output = model(inp_tensor).clamp(0, 1).cpu().squeeze(0).permute(1, 2, 0).numpy()

            psnr = calculate_psnr(output, high_img)
            ssim = calculate_ssim(output, high_img)
            lpips_val = lpips_fn(
                torch.tensor(output).permute(2, 0, 1).unsqueeze(0).float().to(device),
                torch.tensor(high_img).permute(2, 0, 1).unsqueeze(0).float().to(device)
            ).item()

            psnr_list.append(psnr)
            ssim_list.append(ssim)
            lpips_list.append(lpips_val)
    
    return np.mean(psnr_list), np.mean(ssim_list), np.mean(lpips_list)

# === Paths ===
high_dir = "/content/cvccolondbsplit/test/high"
low_dir = "/content/cvccolondbsplit/test/low"

# === Model Variants ===
model_variants = {
    "Baseline_UNet": unet(),
    "DenseUNet": denseunet(),
    "CBAM_UNet": cbam_unet(),
    "CBAM_DenseUNet": cbam_denseunet(),
    "CBAM_DenseUNet_Retinex": cbam_denseunet_retinex()
}

# === Run Ablation Study ===
results = []
for name, model in model_variants.items():
    model.to(device)
    use_retinex = "Retinex" in name
    psnr, ssim, lpips_val = evaluate_model(model, high_dir, low_dir, use_retinex=use_retinex)
    results.append({"Model": name, "PSNR": psnr, "SSIM": ssim, "LPIPS": lpips_val})

# === Save Results ===
df = pd.DataFrame(results)
df.to_csv("ablation_results.csv", index=False)
print("\nâœ… Ablation Study Results Saved to 'ablation_results.csv'")
print(df)
